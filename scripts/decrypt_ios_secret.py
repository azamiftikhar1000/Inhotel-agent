#!/usr/bin/env python3
"""
decrypt_ios_secret.py  ── with logging
-------------------------------------

CLI tool to decrypt the hex-encoded ChaCha20-Poly1305 blob produced by
the Rust IOSCrypto helper.

Usage
-----
python decrypt_ios_secret.py <32-byte-key> <hex-ciphertext> [-v]

    -v | --verbose   enable DEBUG-level output

Example
-------
python decrypt_ios_secret.py \
    replace-this-insecure-secret---- \
    0c3f5d4fd9da84f704e38f75b55fa8f024bf08d3b46ccf38348623a33f42

Requirements
------------
pip install cryptography
"""

import argparse
import binascii
import logging
import sys
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

NONCE_LEN = 12   # bytes
TAG_LEN   = 16   # bytes


def configure_logging(verbose: bool) -> None:
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(levelname)s: %(message)s",
    )


def parse_args() -> tuple[str, str, bool]:
    parser = argparse.ArgumentParser(
        description="Decrypt a hex-encoded ChaCha20-Poly1305 blob "
                    "generated by IOSCrypto::encrypt"
    )
    parser.add_argument("key",  help="32-byte ASCII key (ios_crypto_secret)")
    parser.add_argument("hex",  help="hex-encoded ciphertext")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="enable verbose / debug output")
    ns = parser.parse_args()
    return ns.key, ns.hex, ns.verbose


def main() -> None:
    key_str, hex_blob, verbose = parse_args()
    configure_logging(verbose)
    log = logging.getLogger("decrypt")

    # ── 1. validate & load key ───────────────────────────────
    log.debug("Original key string: %s", key_str)
    if len(key_str) != 32:
        log.error("Key length is %d (expected 32 ASCII chars)", len(key_str))
        sys.exit(1)

    key = key_str.encode("ascii")
    log.info("Key accepted (%d bytes)", len(key))

    # ── 2. hex-decode ────────────────────────────────────────
    log.debug("Hex ciphertext length: %d chars", len(hex_blob))
    try:
        blob = binascii.unhexlify(hex_blob)
    except binascii.Error as e:
        log.error("Ciphertext is not valid hex: %s", e)
        sys.exit(1)

    log.info("Total decoded blob size: %d bytes", len(blob))
    if len(blob) < NONCE_LEN + TAG_LEN:
        log.error("Ciphertext too short: need at least %d bytes", NONCE_LEN + TAG_LEN)
        sys.exit(1)

    # ── 3. split nonce / ciphertext+tag ──────────────────────
    nonce, ciphertext_tag = blob[:NONCE_LEN], blob[NONCE_LEN:]
    log.debug("Nonce: %s", nonce.hex())
    log.debug("Ciphertext+tag length: %d bytes", len(ciphertext_tag))

    # ── 4. decrypt & authenticate ────────────────────────────
    cipher = ChaCha20Poly1305(key)
    try:
        plaintext_bytes = cipher.decrypt(
            nonce,
            ciphertext_tag,
            associated_data=None
        )
    except Exception as e:
        log.error("Decryption failed (wrong key or tampered data): %s", e)
        sys.exit(1)
    log.info("Decryption succeeded")

    # ── 5. UTF-8 decode & print ──────────────────────────────
    try:
        plaintext = plaintext_bytes.decode("utf-8")
    except UnicodeDecodeError as e:
        log.error("Plaintext is not valid UTF-8: %s", e)
        sys.exit(1)

    log.info("Plaintext retrieved successfully")
    print(plaintext)


if __name__ == "__main__":
    main()
